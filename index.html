<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liminal Space 3D World - Video Intro, Music & VHS FX</title> <!-- Updated Title -->
    <style>
        /* CSS remains the same */
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #000; /* Black background for video borders and loading */
        }
        canvas {
            display: none; /* Initially hide the game canvas */
            background-color: #000; /* Should be overridden by scene background */
        }

        #introVideo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: contain; /* Fit video within bounds, maintain aspect ratio */
            background-color: #000; /* Black background for letterboxing */
            z-index: 1000; /* Ensure video is on top initially */
            cursor: pointer; /* Indicate it's clickable */
        }

        #videoOverlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001; /* Above the video */
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px 25px;
            border-radius: 8px;
            pointer-events: none; /* Allow clicks to go through to the video */
            text-align: center;
        }
         #videoOverlay.hidden {
            display: none;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none; /* Initially hidden, shown only when pointer lock is lost */
            justify-content: center;
            align-items: center;
            z-index: 999; /* Below video overlay */
        }
        #instructions {
            width: 80%;
            max-width: 400px;
            cursor: default;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            text-align: center;
            color: #333;
            font-size: 16px;
        }
        #instructions button { display: none; }

        .key {
             background-color: #eee;
             border-radius: 3px;
             border: 1px solid #b4b4b4;
             box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;
             color: #333;
             display: inline-block;
             font-size: .85em;
             font-weight: 700;
             line-height: 1;
             padding: 2px 4px;
             white-space: nowrap;
        }

        @keyframes glitchAnim {
          0% { transform: translate(0); opacity: 1;} 10% { transform: translate(-3px, 3px); opacity: 0.8;} 20% { transform: translate(3px, -3px); opacity: 1;} 30% { transform: translate(-3px, -3px); opacity: 0.9;} 40% { transform: translate(3px, 3px); opacity: 1;} 50% { transform: translate(-3px, 3px); opacity: 0.7;} 60% { transform: translate(3px, -3px); opacity: 1;} 70% { transform: translate(-3px, -3px); opacity: 0.8;} 80% { transform: translate(3px, 3px); opacity: 1;} 90% { transform: translate(-3px, 3px); opacity: 0.9;} 100% { transform: translate(0); opacity: 1;}
        }
        body.glitch { animation: glitchAnim 0.3s linear infinite alternate-reverse; }

    </style>
</head>
<body>
    <!-- Video Element -->
    <video id="introVideo"
           src="https://www.dropbox.com/scl/fi/kjzufbuizw9xtzu66t64m/Generated-File-April-15-2025-4_45PM.mp4?rlkey=m8b3s5956jv8bhw3tzygng770&st=z9jcppk4&dl=1"
           playsinline
           muted>
           Your browser does not support the video tag or the video format.
    </video>
    <div id="videoOverlay">Click to Play</div>

    <!-- Background Music Element -->
    <audio id="bgMusic"
           src="https://www.dropbox.com/scl/fi/6i6nkkycelx485td2b9ji/liminal.mp3.mp3?rlkey=8eprv0pljrzt28hr0kxj89wri&st=ingl76ye&dl=1"
           loop
           preload="metadata"
           muted> <!-- Start muted -->
        Your browser does not support the audio element.
    </audio>

    <!-- Blocker -->
    <div id="blocker">
        <div id="instructions">
             <h2>Paused</h2>
            <p>
                Move: <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span><br>
                Jump: <span class="key">SPACE</span><br>
                Look: Mouse<br><br>
                <i>Click to Resume</i>
            </p>
        </div>
    </div>

    <!-- Three.js canvas appended here -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js",
            "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { HueSaturationShader } from 'three/addons/shaders/HueSaturationShader.js';
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
        import { VignetteShader } from 'three/addons/shaders/VignetteShader.js';

        // --- Global Variables ---
        let scene, camera, renderer, composer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = true;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        const playerHeight = 1.8;
        const playerWidth = 0.5;
        const playerDepth = 0.5;
        const playerSpeed = 12.0;
        const jumpVelocity = 9.0;
        const gravity = 28.0;
        const blockSize = 1;
        const renderDistanceBlocks = 75;
        const renderDistanceUnits = renderDistanceBlocks * blockSize;
        const worldSize = 600;
        const skyColor = 0x87CEEB;
        const fogNear = renderDistanceUnits * 0.3;
        const fogFar = renderDistanceUnits * 1.0;
        let prevTime = performance.now();
        const terrainAmplitude = 8;
        const terrainFrequency = 0.03;
        let groundMesh;
        const collidableObjects = [];
        const houseBaseWidth = 4;
        const houseBaseHeight = 3;
        const houseBaseDepth = 5;
        const fenceHeight = 1.2;
        const fenceOffset = 1.5;
        const playerBox = new THREE.Box3();
        let filmPass;
        let gameStarted = false;
        let musicStarted = false; // Flag for music

        // --- DOM Elements ---
        const introVideo = document.getElementById('introVideo');
        const videoOverlay = document.getElementById('videoOverlay');
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const bgMusicElement = document.getElementById('bgMusic'); // Get audio element


        // --- Pointer Lock Request Function ---
        function requestPointerLock() {
            console.log("Requesting Pointer Lock...");
            document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;
            if (document.body.requestPointerLock) {
                document.body.requestPointerLock();
            } else {
                console.warn("Pointer Lock API not available");
                instructions.innerHTML = "Your browser doesn't support Pointer Lock API. Controls might not work correctly.";
                blocker.style.display = 'flex';
            }
        }

        // --- Glitch Effect Function ---
        function applyGlitch() {
            console.log("Applying glitch effect...");
            document.body.classList.add('glitch');
            setTimeout(() => {
                document.body.classList.remove('glitch');
                console.log("Glitch effect removed.");
            }, 350);
        }

        // --- Start Game Function ---
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            console.log("Video interaction occurred. Starting game sequence...");

            introVideo.style.display = 'none';
            videoOverlay.classList.add('hidden');

            applyGlitch();

            setTimeout(() => {
                console.log("Initializing game...");
                init();
                if (renderer && renderer.domElement) {
                    renderer.domElement.style.display = 'block';
                    console.log("Game canvas displayed.");
                } else {
                     console.error("Renderer or canvas not ready after init!");
                     blocker.style.display = 'flex';
                     instructions.innerHTML = 'Error initializing game graphics. Please refresh.';
                     return;
                }
                animate();
                requestPointerLock();
                console.log("Game started and Pointer Lock requested.");

            }, 150);
        }

        // --- Video Event Listeners ---
        introVideo.addEventListener('click', () => {
            // --- Start Music on First Click ---
            if (!musicStarted && bgMusicElement) {
                console.log("Attempting to play background music...");
                musicStarted = true; // Set flag immediately
                bgMusicElement.muted = false; // Unmute before playing
                bgMusicElement.volume = 0.4; // Set desired volume (0.0 to 1.0)
                bgMusicElement.play().then(() => {
                    console.log("Background music playing.");
                }).catch(error => {
                    console.error("Background music playback failed:", error);
                    // Music might be blocked by browser policy, user may need to interact more
                    // Reset flag if play failed, maybe? Or just log the error.
                    // musicStarted = false; // Optional: reset if failed
                });
            }
            // --- End Music Start ---

            if (!gameStarted) { // Only play video if game hasn't started
                console.log("Video clicked, attempting to play video...");
                videoOverlay.classList.add('hidden'); // Hide overlay on click
                introVideo.play().catch(error => {
                    console.error("Video playback failed:", error);
                    // If video fails BUT music started, we might still want to proceed
                    // If game hasn't started yet, try starting it as a fallback
                    if (!gameStarted) {
                        console.log("Video play failed, attempting to start game anyway...");
                        startGame();
                    }
                    // blocker.style.display = 'flex';
                    // instructions.innerHTML = 'Video playback error. <br>Try refreshing the page or ensure your browser allows video playback.';
                });
            } else {
                 // If game already started and video somehow becomes clickable again,
                 // ensure pointer lock is re-requested if lost.
                 if (document.pointerLockElement !== document.body) {
                    requestPointerLock();
                 }
            }
        });

        introVideo.addEventListener('play', () => {
             console.log("Video playback started.");
             videoOverlay.classList.add('hidden'); // Ensure overlay is hidden
        });

        introVideo.addEventListener('ended', () => {
            console.log("Video naturally ended.");
            // Start game only if it hasn't been started by a click already
            if (!gameStarted) {
                startGame();
            }
        });


        // --- Initialization (Includes Post-Processing Setup) ---
        function init() {
            console.log("Running init()...");
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Start black

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, renderDistanceUnits);
            camera.position.y = getTerrainHeight(0, 0) + playerHeight + 5;
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.domElement.style.display = 'none';
            document.body.appendChild(renderer.domElement);
            console.log("Renderer created.");

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(worldSize * 0.3, 250, worldSize * 0.2);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 10; directionalLight.shadow.camera.far = worldSize * 0.8;
            directionalLight.shadow.camera.left = -worldSize * 0.4; directionalLight.shadow.camera.right = worldSize * 0.4;
            directionalLight.shadow.camera.top = worldSize * 0.4; directionalLight.shadow.camera.bottom = -worldSize * 0.4;
            directionalLight.shadow.bias = -0.001;
            scene.add(directionalLight);
            console.log("Lighting added.");

            // Terrain
            createTerrain();

            // Houses & Fences
            if (groundMesh) {
                 createHousesAndFences();
                 console.log("Houses and fences created.");
            } else {
                console.error("Ground mesh not available, skipping houses/fences.");
            }

            // --- Post Processing Setup ---
            console.log("Setting up Effect Composer...");
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            const hueSaturationPass = new ShaderPass(HueSaturationShader);
            hueSaturationPass.uniforms['saturation'].value = 0.4;
            composer.addPass(hueSaturationPass);
            const rgbShiftPass = new ShaderPass(RGBShiftShader);
            rgbShiftPass.uniforms['amount'].value = 0.0025;
            composer.addPass(rgbShiftPass);
            filmPass = new FilmPass(0.65, 0.5, 1024, false );
            composer.addPass(filmPass);
            const vignettePass = new ShaderPass(VignetteShader);
            vignettePass.uniforms['offset'].value = 0.95;
            vignettePass.uniforms['darkness'].value = 1.5;
            composer.addPass(vignettePass);
            console.log("Effect Composer passes added.");

            // Set final background and fog
            scene.background.set(skyColor);
            scene.fog = new THREE.Fog(skyColor, fogNear, fogFar);
            console.log("Scene background and fog set.");

            // Controls
            setupControls();
            console.log("Control listeners set up.");

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            console.log("Init complete.");
        }

        // --- Terrain Height Calculation --- (Unchanged)
        function getTerrainHeight(worldX, worldZ) { return Math.sin(worldX * terrainFrequency) * Math.cos(worldZ * terrainFrequency) * terrainAmplitude; }

        // --- Terrain Creation (Using StandardMaterial and Normals) --- (Unchanged)
        function createTerrain() { console.log("Creating terrain (StandardMaterial)..."); try { const segments = 60; const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize, segments, segments); const vertices = groundGeometry.attributes.position; for (let i = 0; i < vertices.count; i++) { const x = vertices.getX(i); const y = vertices.getY(i); const worldHeight = getTerrainHeight(x, y); vertices.setZ(i, worldHeight); } vertices.needsUpdate = true; groundGeometry.computeVertexNormals(); console.log("Vertex normals computed."); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x559055, roughness: 0.9, metalness: 0.1, side: THREE.DoubleSide }); groundMesh = new THREE.Mesh(groundGeometry, groundMaterial); groundMesh.rotation.x = -Math.PI / 2; groundMesh.receiveShadow = true; scene.add(groundMesh); console.log("Terrain mesh (StandardMaterial) created and added."); } catch (error) { console.error("Error during terrain creation:", error); groundMesh = null; } }

        // --- Fence Creation Helper (Using StandardMaterial) --- (Unchanged)
        function createFence(houseX, houseZ, houseWidth, houseDepth, terrainY) { const fenceGroup = new THREE.Group(); const postGeometry = new THREE.BoxGeometry(0.15, fenceHeight, 0.15); const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, roughness: 0.8, metalness: 0.1 }); const fencePoints = [ { x: houseX - houseWidth / 2 - fenceOffset, z: houseZ - houseDepth / 2 - fenceOffset }, { x: houseX + houseWidth / 2 + fenceOffset, z: houseZ - houseDepth / 2 - fenceOffset }, { x: houseX + houseWidth / 2 + fenceOffset, z: houseZ + houseDepth / 2 + fenceOffset }, { x: houseX - houseWidth / 2 - fenceOffset, z: houseZ + houseDepth / 2 + fenceOffset } ]; const postSpacing = 1.5; for (let i = 0; i < fencePoints.length; i++) { const startPoint = fencePoints[i]; const endPoint = fencePoints[(i + 1) % fencePoints.length]; const dx = endPoint.x - startPoint.x; const dz = endPoint.z - startPoint.z; const length = Math.sqrt(dx * dx + dz * dz); const angle = Math.atan2(dz, dx); const numPosts = Math.ceil(length / postSpacing) + 1; for (let j = 0; j < numPosts; j++) { const ratio = j / (numPosts - 1); const postX = startPoint.x + dx * ratio; const postZ = startPoint.z + dz * ratio; const postY = getTerrainHeight(postX, postZ) + fenceHeight / 2; const post = new THREE.Mesh(postGeometry, fenceMaterial); post.position.set(postX, postY, postZ); post.castShadow = true; post.receiveShadow = true; fenceGroup.add(post); } const midX = startPoint.x + dx / 2; const midZ = startPoint.z + dz / 2; const midY = getTerrainHeight(midX, midZ); const railY1 = midY + fenceHeight * 0.3; const railY2 = midY + fenceHeight * 0.7; const railGeom = new THREE.BoxGeometry(length, 0.1, 0.1); const rail1 = new THREE.Mesh(railGeom, fenceMaterial); rail1.position.set(midX, railY1, midZ); rail1.rotation.y = angle; rail1.castShadow = true; rail1.receiveShadow = true; fenceGroup.add(rail1); const rail2 = new THREE.Mesh(railGeom, fenceMaterial); rail2.position.set(midX, railY2, midZ); rail2.rotation.y = angle; rail2.castShadow = true; rail2.receiveShadow = true; fenceGroup.add(rail2); } return fenceGroup; }

        // --- House and Fence Placement (Using StandardMaterial) --- (Unchanged)
        function createHousesAndFences() { const houseGroupTemplate = new THREE.Group(); const houseBaseMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.8, metalness: 0.1 }); const baseMesh = new THREE.Mesh(new THREE.BoxGeometry(houseBaseWidth, houseBaseHeight, houseBaseDepth), houseBaseMaterial); houseGroupTemplate.add(baseMesh); const houseRoofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7, metalness: 0.2 }); const roofMesh = new THREE.Mesh(new THREE.ConeGeometry(houseBaseWidth * 0.75, 2, 4), houseRoofMaterial); roofMesh.position.y = houseBaseHeight / 2 + 1; roofMesh.rotation.y = Math.PI / 4; houseGroupTemplate.add(roofMesh); const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.85 }); const doorMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 2), doorMaterial); doorMesh.position.set(0, 0, houseBaseDepth / 2 + 0.01); houseGroupTemplate.add(doorMesh); const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEFA, roughness: 0.2, metalness: 0.1, transparent: true, opacity: 0.8 }); const windowMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1), windowMaterial); windowMesh.position.set(-houseBaseWidth / 2 - 0.01, 0.5, 0); windowMesh.rotation.y = -Math.PI / 2; houseGroupTemplate.add(windowMesh); const windowMesh2 = windowMesh.clone(); windowMesh2.position.set(houseBaseWidth / 2 + 0.01, 0.5, 0); windowMesh2.rotation.y = Math.PI / 2; houseGroupTemplate.add(windowMesh2); const numberOfHouses = 120; const placementSize = worldSize * 0.85; collidableObjects.length = 0; for (let i = 0; i < numberOfHouses; i++) { const houseInstance = houseGroupTemplate.clone(true); let posX, posZ; const minDistance = 20; do { posX = (Math.random() - 0.5) * placementSize; posZ = (Math.random() - 0.5) * placementSize; } while (Math.sqrt(posX*posX + posZ*posZ) < minDistance); const terrainY = getTerrainHeight(posX, posZ); houseInstance.position.set(posX, terrainY + houseBaseHeight / 2, posZ); houseInstance.rotation.y = Math.random() * Math.PI * 2; scene.add(houseInstance); houseInstance.traverse(function (child) { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } }); const houseBox = new THREE.Box3(); let collisionWidth = houseBaseWidth; let collisionDepth = houseBaseDepth; let hasFence = false; if (Math.random() < 0.35) { hasFence = true; const fenceGroup = createFence(posX, posZ, houseBaseWidth, houseBaseDepth, terrainY); scene.add(fenceGroup); collisionWidth += 2 * fenceOffset; collisionDepth += 2 * fenceOffset; } const halfColWidth = collisionWidth / 2; const halfColDepth = collisionDepth / 2; const collisionHeight = hasFence ? Math.max(houseBaseHeight, fenceHeight) : houseBaseHeight; houseBox.min.set(posX - halfColWidth, terrainY, posZ - halfColDepth); houseBox.max.set(posX + halfColWidth, terrainY + collisionHeight, posZ + halfColDepth); collidableObjects.push(houseBox); } }

        // --- Control Setup (Pointer Lock) --- (Unchanged)
        function setupControls() { document.addEventListener('pointerlockchange', lockChangeAlert, false); document.addEventListener('mozpointerlockchange', lockChangeAlert, false); document.addEventListener('webkitpointerlockchange', lockChangeAlert, false); function lockChangeAlert() { if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body || document.webkitPointerLockElement === document.body) { console.log('Pointer Lock Acquired.'); blocker.style.display = 'none'; document.addEventListener("mousemove", onMouseMove, false); document.addEventListener('keydown', onKeyDown, false); document.addEventListener('keyup', onKeyUp, false); } else { console.log('Pointer Lock Lost.'); blocker.style.display = 'flex'; document.removeEventListener("mousemove", onMouseMove, false); document.removeEventListener('keydown', onKeyDown, false); document.removeEventListener('keyup', onKeyUp, false); moveForward = false; moveBackward = false; moveLeft = false; moveRight = false; } } blocker.addEventListener('click', requestPointerLock); }

        // --- Mouse Movement Handler --- (Unchanged)
        function onMouseMove(event) { if (document.pointerLockElement !== document.body) return; const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0; const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0; const euler = new THREE.Euler(0, 0, 0, 'YXZ'); euler.setFromQuaternion(camera.quaternion); euler.y -= movementX * 0.002; euler.x -= movementY * 0.002; euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); camera.quaternion.setFromEuler(euler); }

        // --- Keyboard Handlers --- (Unchanged)
        function onKeyDown(event) { switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = true; event.preventDefault(); break; case 'ArrowLeft': case 'KeyA': moveLeft = true; event.preventDefault(); break; case 'ArrowDown': case 'KeyS': moveBackward = true; event.preventDefault(); break; case 'ArrowRight': case 'KeyD': moveRight = true; event.preventDefault(); break; case 'Space': if (canJump === true) velocity.y += jumpVelocity; canJump = false; event.preventDefault(); break; } } function onKeyUp(event) { switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = false; break; case 'ArrowLeft': case 'KeyA': moveLeft = false; break; case 'ArrowDown': case 'KeyS': moveBackward = false; break; case 'ArrowRight': case 'KeyD': moveRight = false; break; } }

        // --- Window Resize (Handles Composer) --- (Unchanged)
        function onWindowResize() { if (!camera || !renderer || !composer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); console.log("Resized renderer and composer."); }

        // --- Collision Check Function --- (Unchanged)
        function checkCollisions(playerNextPosBox) { for (const objectBox of collidableObjects) { if (playerNextPosBox.intersectsBox(objectBox)) { return true; } } return false; }

        // --- Animation Loop (Uses Composer, Updates Film Pass) --- (Unchanged)
        function animate() { if (!renderer || !scene || !camera || !composer || !gameStarted) { return; } requestAnimationFrame(animate); const time = performance.now(); const delta = Math.min(0.05, (time - prevTime) / 1000); velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= gravity * delta; direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize(); const speedFactor = playerSpeed * delta; let moveX = 0; let moveZ = 0; if (moveForward || moveBackward || moveLeft || moveRight) { const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection); cameraDirection.y = 0; cameraDirection.normalize(); const forwardMove = cameraDirection.clone().multiplyScalar(direction.z * speedFactor); const strafeMove = cameraDirection.clone().cross(camera.up).multiplyScalar(direction.x * speedFactor); moveX = forwardMove.x + strafeMove.x; moveZ = forwardMove.z + strafeMove.z; } const currentPos = camera.position; const nextPlayerPosXZ = currentPos.clone(); nextPlayerPosXZ.x += moveX; nextPlayerPosXZ.z += moveZ; const playerCenterY = currentPos.y - playerHeight / 2; playerBox.setFromCenterAndSize( new THREE.Vector3(nextPlayerPosXZ.x, playerCenterY, nextPlayerPosXZ.z), new THREE.Vector3(playerWidth, playerHeight, playerDepth) ); if (!checkCollisions(playerBox)) { camera.position.x = nextPlayerPosXZ.x; camera.position.z = nextPlayerPosXZ.z; } else { velocity.x = 0; velocity.z = 0; } camera.position.y += velocity.y * delta; const terrainY = getTerrainHeight(camera.position.x, camera.position.z); const groundCheckPos = terrainY + playerHeight; if (camera.position.y < groundCheckPos) { velocity.y = 0; camera.position.y = groundCheckPos; canJump = true; } if(filmPass) { filmPass.uniforms['time'].value += delta; } composer.render(delta); prevTime = time; }

        // --- Initial Setup ---
        console.log("Page loaded. Waiting for video interaction.");

    </script>
</body>
</html>
