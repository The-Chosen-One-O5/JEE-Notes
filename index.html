<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liminal Space 3D World - Video Intro</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #000; /* Black background for video borders and loading */
        }
        canvas {
            display: none; /* Initially hide the game canvas */
            background-color: #000; /* Should be overridden by scene background */
        }

        #introVideo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: contain; /* Fit video within bounds, maintain aspect ratio */
            background-color: #000; /* Black background for letterboxing */
            z-index: 1000; /* Ensure video is on top initially */
            cursor: pointer; /* Indicate it's clickable */
        }

        #videoOverlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001; /* Above the video */
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px 25px;
            border-radius: 8px;
            pointer-events: none; /* Allow clicks to go through to the video */
            text-align: center;
        }
         #videoOverlay.hidden {
            display: none;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none; /* Initially hidden, shown only when pointer lock is lost */
            justify-content: center;
            align-items: center;
            z-index: 999; /* Below video overlay */
        }
        #instructions {
            width: 80%;
            max-width: 400px;
            cursor: default;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            text-align: center;
            color: #333;
            font-size: 16px;
        }
        /* No Start button needed in instructions now for initial start */
        #instructions button { display: none; } /* Hide the specific start button */

        .key {
             background-color: #eee;
             border-radius: 3px;
             border: 1px solid #b4b4b4;
             box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;
             color: #333;
             display: inline-block;
             font-size: .85em;
             font-weight: 700;
             line-height: 1;
             padding: 2px 4px;
             white-space: nowrap;
        }

        /* --- Glitch Effect (Optional) --- */
        @keyframes glitchAnim {
          0% { transform: translate(0); opacity: 1;}
          10% { transform: translate(-3px, 3px); opacity: 0.8;}
          20% { transform: translate(3px, -3px); opacity: 1;}
          30% { transform: translate(-3px, -3px); opacity: 0.9;}
          40% { transform: translate(3px, 3px); opacity: 1;}
          50% { transform: translate(-3px, 3px); opacity: 0.7;}
          60% { transform: translate(3px, -3px); opacity: 1;}
          70% { transform: translate(-3px, -3px); opacity: 0.8;}
          80% { transform: translate(3px, 3px); opacity: 1;}
          90% { transform: translate(-3px, 3px); opacity: 0.9;}
          100% { transform: translate(0); opacity: 1;}
        }
        body.glitch {
          animation: glitchAnim 0.3s linear infinite alternate-reverse;
          /* Apply filter for more effect - adjust as needed */
          /* filter: hue-rotate(10deg) contrast(1.2) saturate(1.5); */
        }
        /* --- End Glitch Effect --- */

    </style>
</head>
<body>
    <!-- Video Element -->
    <video id="introVideo"
           src="https://www.dropbox.com/scl/fi/kjzufbuizw9xtzu66t64m/Generated-File-April-15-2025-4_45PM.mp4?rlkey=m8b3s5956jv8bhw3tzygng770&st=z9jcppk4&dl=1"
           playsinline
           muted>
           <!-- Muted increases chance of autoplay -->
           Your browser does not support the video tag or the video format.
    </video>
    <div id="videoOverlay">Click to Play</div>

    <!-- Blocker for instructions when pointer lock is lost -->
    <div id="blocker">
        <div id="instructions">
             <h2>Paused</h2> <!-- Changed title -->
            <p>
                Move: <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span><br>
                Jump: <span class="key">SPACE</span><br>
                Look: Mouse<br><br>
                <i>Click to Resume</i>
            </p>
            <!-- Removed the explicit start button -->
        </div>
    </div>

    <!-- Three.js canvas will be appended here by the script -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = true;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        const playerHeight = 1.8;
        const playerWidth = 0.5;
        const playerDepth = 0.5;
        const playerSpeed = 12.0;
        const jumpVelocity = 9.0;
        const gravity = 28.0;
        const blockSize = 1;
        const renderDistanceBlocks = 75;
        const renderDistanceUnits = renderDistanceBlocks * blockSize;
        const worldSize = 600;
        const skyColor = 0x87CEEB; // Keep original sky color for the game
        const fogNear = renderDistanceUnits * 0.3;
        const fogFar = renderDistanceUnits * 1.0;
        let prevTime = performance.now();
        const terrainAmplitude = 8;
        const terrainFrequency = 0.03;
        let groundMesh;
        const collidableObjects = [];
        const houseBaseWidth = 4;
        const houseBaseHeight = 3;
        const houseBaseDepth = 5;
        const fenceHeight = 1.2;
        const fenceOffset = 1.5;
        const playerBox = new THREE.Box3();
        let gameStarted = false; // Flag to prevent multiple initializations

        // --- DOM Elements ---
        const introVideo = document.getElementById('introVideo');
        const videoOverlay = document.getElementById('videoOverlay');
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');


        // --- Pointer Lock Request Function ---
        function requestPointerLock() {
            console.log("Requesting Pointer Lock...");
            document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;
            if (document.body.requestPointerLock) {
                document.body.requestPointerLock();
            } else {
                console.warn("Pointer Lock API not available");
                instructions.innerHTML = "Your browser doesn't support Pointer Lock API. Controls might not work correctly.";
                blocker.style.display = 'flex'; // Show blocker if lock fails
            }
        }

        // --- Glitch Effect Function ---
        function applyGlitch() {
            console.log("Applying glitch effect...");
            document.body.classList.add('glitch');
            // Remove glitch class after its duration
            setTimeout(() => {
                document.body.classList.remove('glitch');
                console.log("Glitch effect removed.");
            }, 350); // Duration slightly longer than animation to ensure it finishes
        }

        // --- Start Game Function ---
        function startGame() {
            if (gameStarted) return; // Prevent running twice
            gameStarted = true;
            console.log("Video ended. Starting game sequence...");

            introVideo.style.display = 'none'; // Hide video
            videoOverlay.classList.add('hidden'); // Hide overlay permanently

            // Apply glitch effect
            applyGlitch();

            // Wait a short moment for glitch effect to be visible before heavy init
            setTimeout(() => {
                console.log("Initializing game...");
                init(); // Setup Three.js scene, renderer, objects, controls
                if (renderer && renderer.domElement) {
                    renderer.domElement.style.display = 'block'; // Show the canvas
                    console.log("Game canvas displayed.");
                } else {
                     console.error("Renderer or canvas not ready after init!");
                     // Handle error - maybe show a message
                     blocker.style.display = 'flex';
                     instructions.innerHTML = 'Error initializing game graphics. Please refresh.';
                     return;
                }
                animate(); // Start the render loop
                requestPointerLock(); // Lock cursor for controls
                console.log("Game started and Pointer Lock requested.");

            }, 150); // Short delay (milliseconds) after glitch starts
        }

        // --- Video Event Listeners ---
        introVideo.addEventListener('click', () => {
            if (!gameStarted) { // Only play if game hasn't started
                console.log("Video clicked, attempting to play...");
                videoOverlay.classList.add('hidden'); // Hide overlay on click
                introVideo.play().catch(error => {
                    console.error("Video playback failed:", error);
                    // Maybe show an error message or try starting game directly?
                    // For now, we'll rely on the 'ended' event if it somehow plays later
                    // Or potentially call startGame() here as a fallback?
                    // Let's add a fallback: if play fails, start game anyway
                    // after a small delay to avoid race conditions.
                    // setTimeout(startGame, 100); // Fallback: start game if play fails
                    blocker.style.display = 'flex';
                    instructions.innerHTML = 'Video playback error. <br>Try refreshing the page or ensure your browser allows video playback.';
                });
            }
        });

        introVideo.addEventListener('play', () => {
             console.log("Video playback started.");
             videoOverlay.classList.add('hidden'); // Ensure overlay is hidden when play begins
        });

        introVideo.addEventListener('ended', () => {
            console.log("Video naturally ended.");
            startGame(); // Start the game when video finishes
        });


        // --- Initialization ---
        function init() {
            console.log("Running init()...");
            scene = new THREE.Scene();
            // Use black background initially, then switch to sky color
            scene.background = new THREE.Color(0x000000); // Start black
            // scene.fog = new THREE.Fog(skyColor, fogNear, fogFar); // Fog added later

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, renderDistanceUnits);
            // Start position adjusted based on potential terrain height at 0,0
            camera.position.y = getTerrainHeight(0, 0) + playerHeight + 5; // Initial Y pos
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.domElement.style.display = 'none'; // Ensure canvas is hidden initially
            document.body.appendChild(renderer.domElement);
            console.log("Renderer created and canvas appended (hidden).");

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(worldSize * 0.3, 250, worldSize * 0.2);
            directionalLight.castShadow = true;
            // Shadow map settings (same as before)
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 10; directionalLight.shadow.camera.far = worldSize * 0.8;
            directionalLight.shadow.camera.left = -worldSize * 0.4; directionalLight.shadow.camera.right = worldSize * 0.4;
            directionalLight.shadow.camera.top = worldSize * 0.4; directionalLight.shadow.camera.bottom = -worldSize * 0.4;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);
            console.log("Lighting added.");

            // Terrain
            createTerrain(); // This might take a moment

            // Houses & Fences
            if (groundMesh) {
                 createHousesAndFences();
                 console.log("Houses and fences created.");
            } else {
                console.error("Ground mesh not available after creation, skipping houses/fences.");
            }

            // Set background and fog *after* potential heavy loading
            scene.background.set(skyColor);
            scene.fog = new THREE.Fog(skyColor, fogNear, fogFar);
            console.log("Scene background and fog set.");


            // Controls - Setup listeners but don't attach mousemove yet
            setupControls();
            console.log("Control listeners set up.");

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            console.log("Init complete.");
        }

        // --- Terrain Height Calculation ---
        function getTerrainHeight(worldX, worldZ) {
            // Same as before
            return Math.sin(worldX * terrainFrequency) * Math.cos(worldZ * terrainFrequency) * terrainAmplitude;
        }

        // --- Terrain Creation ---
        function createTerrain() {
            // Same as before - logging added for clarity
            console.log("Creating terrain...");
            try {
                const segments = 50;
                const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize, segments, segments);
                const vertices = groundGeometry.attributes.position;
                console.log(`Modifying ${vertices.count} vertices...`);
                for (let i = 0; i < vertices.count; i++) {
                    const x = vertices.getX(i);
                    const y = vertices.getY(i);
                    const worldHeight = getTerrainHeight(x, y);
                    vertices.setZ(i, worldHeight);
                }
                vertices.needsUpdate = true;
                console.log("Vertex modification complete.");

                const groundMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3c7a3c,
                    side: THREE.DoubleSide
                });
                groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                groundMesh.rotation.x = -Math.PI / 2;
                groundMesh.receiveShadow = false;
                scene.add(groundMesh);
                console.log("Terrain mesh created and added:", groundMesh);
            } catch (error) {
                console.error("Error during terrain creation:", error);
                groundMesh = null;
            }
        }


        // --- Fence Creation Helper --- (Unchanged)
        function createFence(houseX, houseZ, houseWidth, houseDepth, terrainY) { const fenceGroup = new THREE.Group(); const postGeometry = new THREE.BoxGeometry(0.15, fenceHeight, 0.15); const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 }); const fencePoints = [ { x: houseX - houseWidth / 2 - fenceOffset, z: houseZ - houseDepth / 2 - fenceOffset }, { x: houseX + houseWidth / 2 + fenceOffset, z: houseZ - houseDepth / 2 - fenceOffset }, { x: houseX + houseWidth / 2 + fenceOffset, z: houseZ + houseDepth / 2 + fenceOffset }, { x: houseX - houseWidth / 2 - fenceOffset, z: houseZ + houseDepth / 2 + fenceOffset } ]; const postSpacing = 1.5; for (let i = 0; i < fencePoints.length; i++) { const startPoint = fencePoints[i]; const endPoint = fencePoints[(i + 1) % fencePoints.length]; const dx = endPoint.x - startPoint.x; const dz = endPoint.z - startPoint.z; const length = Math.sqrt(dx * dx + dz * dz); const angle = Math.atan2(dz, dx); const numPosts = Math.ceil(length / postSpacing) + 1; for (let j = 0; j < numPosts; j++) { const ratio = j / (numPosts - 1); const postX = startPoint.x + dx * ratio; const postZ = startPoint.z + dz * ratio; const postY = getTerrainHeight(postX, postZ) + fenceHeight / 2; const post = new THREE.Mesh(postGeometry, fenceMaterial); post.position.set(postX, postY, postZ); post.castShadow = true; fenceGroup.add(post); } const railY1 = getTerrainHeight(startPoint.x + dx/2, startPoint.z + dz/2) + fenceHeight * 0.3; const railY2 = getTerrainHeight(startPoint.x + dx/2, startPoint.z + dz/2) + fenceHeight * 0.7; const rail1 = new THREE.Mesh(new THREE.BoxGeometry(length, 0.1, 0.1), fenceMaterial); rail1.position.set(startPoint.x + dx / 2, railY1, startPoint.z + dz / 2); rail1.rotation.y = angle; rail1.castShadow = true; fenceGroup.add(rail1); const rail2 = new THREE.Mesh(new THREE.BoxGeometry(length, 0.1, 0.1), fenceMaterial); rail2.position.set(startPoint.x + dx / 2, railY2, startPoint.z + dz / 2); rail2.rotation.y = angle; rail2.castShadow = true; fenceGroup.add(rail2); } return fenceGroup; }

        // --- House and Fence Placement --- (Unchanged)
        function createHousesAndFences() { const houseGroupTemplate = new THREE.Group(); const houseBaseMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5DC }); const baseMesh = new THREE.Mesh(new THREE.BoxGeometry(houseBaseWidth, houseBaseHeight, houseBaseDepth), houseBaseMaterial); baseMesh.castShadow = true; baseMesh.receiveShadow = true; houseGroupTemplate.add(baseMesh); const houseRoofMaterial = new THREE.MeshStandardMaterial({ color: 0xDC143C }); const roofMesh = new THREE.Mesh(new THREE.ConeGeometry(houseBaseWidth * 0.75, 2, 4), houseRoofMaterial); roofMesh.position.y = houseBaseHeight / 2 + 1; roofMesh.rotation.y = Math.PI / 4; roofMesh.castShadow = true; houseGroupTemplate.add(roofMesh); const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); const doorMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 2), doorMaterial); doorMesh.position.set(0, 0, houseBaseDepth / 2 + 0.01); houseGroupTemplate.add(doorMesh); const windowMaterial = new THREE.MeshStandardMaterial({ color: 0xADD8E6 }); const windowMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1), windowMaterial); windowMesh.position.set(-houseBaseWidth / 2 - 0.01, 0.5, 0); windowMesh.rotation.y = -Math.PI / 2; houseGroupTemplate.add(windowMesh); const windowMesh2 = windowMesh.clone(); windowMesh2.position.set(houseBaseWidth / 2 + 0.01, 0.5, 0); windowMesh2.rotation.y = Math.PI / 2; houseGroupTemplate.add(windowMesh2); const numberOfHouses = 120; const placementSize = worldSize * 0.85; collidableObjects.length = 0; for (let i = 0; i < numberOfHouses; i++) { const houseInstance = houseGroupTemplate.clone(); let posX, posZ; const minDistance = 20; do { posX = (Math.random() - 0.5) * placementSize; posZ = (Math.random() - 0.5) * placementSize; } while (Math.sqrt(posX*posX + posZ*posZ) < minDistance); const terrainY = getTerrainHeight(posX, posZ); houseInstance.position.set(posX, terrainY + houseBaseHeight / 2, posZ); houseInstance.rotation.y = Math.random() * Math.PI * 2; scene.add(houseInstance); const houseBox = new THREE.Box3(); let collisionWidth = houseBaseWidth; let collisionDepth = houseBaseDepth; let hasFence = false; if (Math.random() < 0.35) { hasFence = true; const fenceGroup = createFence(posX, posZ, houseBaseWidth, houseBaseDepth, terrainY); scene.add(fenceGroup); collisionWidth += 2 * fenceOffset; collisionDepth += 2 * fenceOffset; } const halfColWidth = collisionWidth / 2; const halfColDepth = collisionDepth / 2; const collisionHeight = hasFence ? Math.max(houseBaseHeight, fenceHeight) : houseBaseHeight; houseBox.min.set(posX - halfColWidth, terrainY, posZ - halfColDepth); houseBox.max.set(posX + halfColWidth, terrainY + collisionHeight, posZ + halfColDepth); collidableObjects.push(houseBox); } }


        // --- Control Setup (Pointer Lock) ---
        function setupControls() {
             // Note: The startButton listener is removed as game start is triggered by video end
             //       The requestPointerLock() call is now in startGame()

             document.addEventListener('pointerlockchange', lockChangeAlert, false);
             document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
             document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);

             function lockChangeAlert() {
                 if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body || document.webkitPointerLockElement === document.body) {
                     console.log('Pointer Lock Acquired.');
                     blocker.style.display = 'none'; // Hide instructions when locked
                     document.addEventListener("mousemove", onMouseMove, false);
                     document.addEventListener('keydown', onKeyDown, false); // Add key listeners only when locked
                     document.addEventListener('keyup', onKeyUp, false);
                 } else {
                     console.log('Pointer Lock Lost.');
                     blocker.style.display = 'flex'; // Show instructions when unlocked
                     document.removeEventListener("mousemove", onMouseMove, false);
                     document.removeEventListener('keydown', onKeyDown, false); // Remove key listeners when unlocked
                     document.removeEventListener('keyup', onKeyUp, false);
                     // Reset movement keys state when focus is lost
                     moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
                 }
             }

            // Add click listener to the blocker itself to re-request pointer lock when paused
            blocker.addEventListener('click', requestPointerLock);
        }

        // --- Mouse Movement Handler --- (Unchanged)
        function onMouseMove(event) { if (document.pointerLockElement !== document.body) return; const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0; const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0; const euler = new THREE.Euler(0, 0, 0, 'YXZ'); euler.setFromQuaternion(camera.quaternion); euler.y -= movementX * 0.002; euler.x -= movementY * 0.002; euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); camera.quaternion.setFromEuler(euler); }

        // --- Keyboard Handlers --- (Unchanged, but listeners added/removed by lockChangeAlert)
        function onKeyDown(event) { switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = true; break; case 'ArrowLeft': case 'KeyA': moveLeft = true; break; case 'ArrowDown': case 'KeyS': moveBackward = true; break; case 'ArrowRight': case 'KeyD': moveRight = true; break; case 'Space': if (canJump === true) velocity.y += jumpVelocity; canJump = false; break; } }
        function onKeyUp(event) { switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = false; break; case 'ArrowLeft': case 'KeyA': moveLeft = false; break; case 'ArrowDown': case 'KeyS': moveBackward = false; break; case 'ArrowRight': case 'KeyD': moveRight = false; break; } }

        // --- Window Resize --- (Unchanged)
        function onWindowResize() { if (!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Collision Check Function --- (Unchanged)
        function checkCollisions(playerNextPosBox) { for (const objectBox of collidableObjects) { if (playerNextPosBox.intersectsBox(objectBox)) { return true; } } return false; }


        // --- Animation Loop --- (Unchanged)
        function animate() {
            // Ensure game has initialized before running animation loop
            if (!renderer || !scene || !camera || !gameStarted) {
                 console.warn("animate() called before init() or after game stopped.");
                 return; // Don't run if not initialized
            }

            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min(0.05, (time - prevTime) / 1000); // Cap delta time

            // --- Physics Update ---
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= gravity * delta; // Apply gravity

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); // Ensure consistent speed in diagonals

            const speedFactor = playerSpeed * delta;
            let moveX = 0;
            let moveZ = 0;

            if (moveForward || moveBackward || moveLeft || moveRight) {
                // Calculate movement based on camera direction (ignoring pitch)
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                cameraDirection.y = 0; // Project onto XZ plane
                cameraDirection.normalize();

                const forwardMove = cameraDirection.clone().multiplyScalar(direction.z * speedFactor);
                const strafeMove = cameraDirection.clone().cross(camera.up).multiplyScalar(direction.x * speedFactor); // Use cross product for strafe vector

                moveX = forwardMove.x + strafeMove.x;
                moveZ = forwardMove.z + strafeMove.z;
            }

            // --- Collision Detection ---
            const currentPos = camera.position;
            const nextPlayerPos = currentPos.clone();

            // Check XZ movement collision
            const nextPlayerPosXZ = currentPos.clone();
            nextPlayerPosXZ.x += moveX;
            nextPlayerPosXZ.z += moveZ;
            const playerCenterY = currentPos.y - playerHeight / 2; // Center Y for bounding box

            playerBox.setFromCenterAndSize(
                 new THREE.Vector3(nextPlayerPosXZ.x, playerCenterY, nextPlayerPosXZ.z),
                 new THREE.Vector3(playerWidth, playerHeight, playerDepth)
            );

            if (!checkCollisions(playerBox)) {
                camera.position.x = nextPlayerPosXZ.x;
                camera.position.z = nextPlayerPosXZ.z;
            } else {
                // Collision detected in XZ, potentially slide? Simple stop for now.
                velocity.x = 0;
                velocity.z = 0;
                // You could implement sliding logic here by checking X and Z collisions separately
            }

            // --- Vertical Movement and Ground Check ---
            camera.position.y += velocity.y * delta;

            const terrainY = getTerrainHeight(camera.position.x, camera.position.z);
            const groundCheckPos = terrainY + playerHeight; // Player feet should be at playerHeight above terrain

            if (camera.position.y < groundCheckPos) {
                velocity.y = 0; // Stop falling
                camera.position.y = groundCheckPos; // Snap to ground
                canJump = true; // Allow jumping again
            }

            // --- Rendering ---
            renderer.render(scene, camera);

            prevTime = time; // Update previous time for next frame delta calculation
        }

        // --- Initial Setup ---
        // NOTE: init() and animate() are NOT called here anymore.
        // They are called by startGame() after the video interaction.
        console.log("Page loaded. Waiting for video interaction.");

    </script>
</body>
</html>
